from pathlib import Path
from typing import Callable, Optional, Tuple

import h5py
import numpy as np
import torch
from torch.utils.data import Dataset


class PCAMDataset(Dataset):
    """
    PatchCamelyon (PCAM) Dataset reader for H5 format.
    """

    def __init__(self, x_path: str, y_path: str, transform: Optional[Callable] = None, filter_data: bool = False):
        self.x_path = Path(x_path)
        self.y_path = Path(y_path)
        self.transform = transform

        # TODO: Initialize dataset
        # 1. Check if files exist
        if self.x_path.exists() is False or self.y_path.exists() is False:
            raise FileNotFoundError("The files don't exist.")
        
        # 2. Open h5 files in read mode
        self.x_file = h5py.File(self.x_path, 'r')  
        self.y_file = h5py.File(self.y_path, 'r')  

        self.x_data = self.x_file['x']  
        self.y_data = self.y_file['y']  

        
        ######## Part generated by ChatGPT########
        ######## The prompt was about filtering out black/white images#########
        if filter_data:
            means = self.x_data[:].mean(axis=(1, 2, 3))
            self.indices = np.where((means > 0) & (means < 255))[0]
        else:
            self.indices = np.arange(len(self.x_data))
        ######### End of ChatGPT part##############

    def __len__(self) -> int:
        # TODO: Return length of dataset
        # The dataloader will know hence how many batches to create
        return len(self.x_data)

    def __getitem__(self, idx: int) -> Tuple[torch.Tensor, torch.Tensor]:
        # TODO: Implement data retrieval
        # 1. Read data at idx
        x_data = self.x_data[idx]
        y_data = int(self.y_data[idx])        
        
        # 2. Convert to uint8 (for PIL compatibility if using transforms)
        x_uint8 = (x_data * 255).astype(np.uint8)

        # 3. Apply transforms if they exist
        if self.transform is not None:
            x_data = self.transform(x_uint8)
        else: 
            # permute is to change the order of Height*Width*Channels -> C*H*W 
            # which is used by PyTorch
            x_data = torch.from_numpy(x_uint8).permute(2, 0, 1).float() / 255.0

        # 4. Return tensor image and label (as long)
        y_data = torch.tensor(y_data).long()
        return x_data, y_data